<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title> Use Weka in your Java code - Weka Wiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = " Use Weka in your Java code";
    var mkdocs_page_input_path = "use_weka_in_your_java_code.md";
    var mkdocs_page_url = "/use_weka_in_your_java_code/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Weka Wiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Resources</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../faq/">FAQ</a>
                </li>
                <li class="">
                    
    <a class="" href="../not_so_faq/">Not so FAQ</a>
                </li>
                <li class="">
                    
    <a class="" href="../troubleshooting/">Troubleshooting</a>
                </li>
                <li class="">
                    
    <a class="" href="../learning_resources/">Learning resources</a>
                </li>
                <li class="">
                    
    <a class="" href="../using_the_api/">Using the API</a>
                </li>
                <li class="">
                    
    <a class="" href="../extending_weka/">Extending Weka</a>
                </li>
                <li class="">
                    
    <a class="" href="../arff/">ARFF Format</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../packages/">Packages</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../mailing_list/">Mailing list</a>
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1 current">
		
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#instances">Instances</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#datasets">Datasets</a></li>
        
            <li><a class="toctree-l3" href="#database">Database</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#option-handling">Option handling</a></li>
    

    <li class="toctree-l2"><a href="#filter">Filter</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#filtering-on-the-fly">Filtering on-the-fly</a></li>
        
            <li><a class="toctree-l3" href="#batch-filtering">Batch filtering</a></li>
        
            <li><a class="toctree-l3" href="#calling-conventions">Calling conventions</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#classification">Classification</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#building-a-classifier">Building a Classifier</a></li>
        
            <li><a class="toctree-l3" href="#evaluating">Evaluating</a></li>
        
            <li><a class="toctree-l3" href="#classifying-instances">Classifying instances</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#clustering">Clustering</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#building-a-clusterer">Building a Clusterer</a></li>
        
            <li><a class="toctree-l3" href="#evaluating_1">Evaluating</a></li>
        
            <li><a class="toctree-l3" href="#clustering-instances">Clustering instances</a></li>
        
            <li><a class="toctree-l3" href="#classes-to-clusters-evaluation">Classes to clusters evaluation</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#attribute-selection">Attribute selection</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#meta-classifier">Meta-Classifier</a></li>
        
            <li><a class="toctree-l3" href="#filter_1">Filter</a></li>
        
            <li><a class="toctree-l3" href="#low-level">Low-level</a></li>
        
        </ul>
    

    <li class="toctree-l2"><a href="#note-on-randomization">Note on randomization</a></li>
    

    <li class="toctree-l2"><a href="#see-also">See also</a></li>
    

    <li class="toctree-l2"><a href="#examples">Examples</a></li>
    

    <li class="toctree-l2"><a href="#links">Links</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
            <li class="toctree-l1">
		
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Weka Wiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li> Use Weka in your Java code</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>The most common components you might want to use are
<em> </em>Instances<em> - your data
</em> <em>Filter</em> - for preprocessing the data
<em> </em>Classifier/Clusterer<em> - built on the processed data
</em> <em>Evaluating</em> - how good is the classifier/clusterer?
<em> </em>Attribute selection* - removing irrelevant attributes from your data</p>
<p>The following sections explain how to use them in your own code. A link to an <strong>example class</strong> can be found at the end of this page, under the <a href="#links">Links</a> section. The classifiers and filters always list their options in the Javadoc API (<a href="http://weka.sourceforge.net/doc.stable/">stable</a>, <a href="http://weka.sourceforge.net/doc.dev/">developer</a> version) specification.</p>
<p>A comprehensive source of information is the chapter <em>Using the API</em> of the Weka manual.</p>
<h1 id="instances">Instances</h1>
<h2 id="datasets">Datasets</h2>
<p>The <code>DataSource</code> class is not limited to ARFF files. It can also read CSV files and other formats (basically all file formats that Weka can import via its converters; it uses the file extension to determine the associated loader).</p>
<pre><code class="java"> import weka.core.converters.ConverterUtils.DataSource;
 ...
 DataSource source = new DataSource(&quot;/some/where/data.arff&quot;);
 Instances data = source.getDataSet();
 // setting class attribute if the data format does not provide this information
 // For example, the XRFF format saves the class attribute information as well
 if (data.classIndex() == -1)
   data.setClassIndex(data.numAttributes() - 1);
</code></pre>

<h2 id="database">Database</h2>
<p>Reading from <a href="../databases/">Databases</a> is slightly more complicated, but still very easy. First, you'll have to modify your <a href="../databases#configuration-files">DatabaseUtils.props</a> file to reflect your database connection. Suppose you want to connect to a <a href="http://wwww.mysql.com/">MySQL</a> server that is running on the local machine on the default port <code>3306</code>. The MySQL JDBC driver is called <a href="http://dev.mysql.com/downloads/connector/j/">Connector/J</a>. (The driver class is <code>org.gjt.mm.mysql.Driver</code>.) The database where your target data resides is called <code>some_database</code>. Since you're only reading, you can use the default user <code>nobody</code> without a password. Your props file must contain the following lines:</p>
<pre><code class="ini"> jdbcDriver=org.gjt.mm.mysql.Driver
 jdbcURL=jdbc:mysql://localhost:3306/some_database
</code></pre>

<p>Secondly, your Java code needs to look like this to load the data from the database:</p>
<pre><code class="java"> import weka.core.Instances;
 import weka.experiment.InstanceQuery;
 ...
 InstanceQuery query = new InstanceQuery();
 query.setUsername(&quot;nobody&quot;);
 query.setPassword(&quot;&quot;);
 query.setQuery(&quot;select * from whatsoever&quot;);
 // You can declare that your data set is sparse
 // query.setSparseData(true);
 Instances data = query.retrieveInstances();
</code></pre>

<p><strong>Notes:</strong>
<em> Don't forget to add the JDBC driver to your <code>CLASSPATH</code>.
</em> For MS Access, you must use the JDBC-ODBC-bridge that is part of a JDK. The [[Windows databases]] article explains how to do this.
* InstanceQuery automatically converts VARCHAR database columns to NOMINAL attributes, and long TEXT database columns to STRING attributes. So if you use InstanceQuery to do text mining against text that appears in a VARCHAR column, Weka will regard such text as nominal values. Thus it will fail to tokenize and mine that text. Use the <code>NominalToString</code> or <code>StringToNominal</code> filter (package <code>weka.filters.unsupervised.attribute</code>) to convert the attributes into the correct type.</p>
<h1 id="option-handling">Option handling</h1>
<p>Weka schemes that implement the <code>weka.core.OptionHandler</code> interface, such as classifiers, clusterers, and filters, offer the following methods for setting and retrieving options:</p>
<ul>
<li><code>void setOptions(String[] options)</code></li>
<li><code>String[] getOptions()</code></li>
</ul>
<p>There are several ways of setting the options:</p>
<ul>
<li>Manually creating a String array:</li>
</ul>
<pre><code class="java">   String[] options = new String[2];
   options[0] = &quot;-R&quot;;
   options[1] = &quot;1&quot;;
</code></pre>

<ul>
<li>Using a single command-line string and using the <code>splitOptions</code> method of the <code>weka.core.Utils</code> class to turn it into an array:</li>
</ul>
<pre><code class="java">    String[] options = weka.core.Utils.splitOptions(&quot;-R 1&quot;);
</code></pre>

<ul>
<li>Using the <a href="../files/OptionsToCode.java">OptionsToCode.java</a> class to automatically turn a command line into code. Especially handy if the command line contains nested classes that have their own options, such as kernels for SMO:</li>
</ul>
<pre><code class="bash">  java OptionsToCode weka.classifiers.functions.SMO
</code></pre>

<p>will generate output like this:</p>
<pre><code class="java"> // create new instance of scheme
 weka.classifiers.functions.SMO scheme = new weka.classifiers.functions.SMO();
 // set options
 scheme.setOptions(weka.core.Utils.splitOptions(&quot;-C 1.0 -L 0.0010 -P 1.0E-12 -N 0 -V -1 -W 1 -K \&quot;weka.classifiers.functions.supportVector.PolyKernel -C 250007 -E 1.0\&quot;&quot;));
</code></pre>

<p>Also, the <a href="../files/OptionTree.java">OptionTree.java</a> tool allows you to view a nested options string, e.g., used at the command line, as a tree. This can help you spot nesting errors.</p>
<h1 id="filter">Filter</h1>
<p>A filter has two different properties:</p>
<ul>
<li>
<p><em>supervised</em> or <em>unsupervised</em>
  either takes the class attribute into account or not</p>
</li>
<li>
<p><em>attribute</em>- or <em>instance</em>-based
  e.g., removing a certain attribute or removing instances that meet a certain condition</p>
</li>
</ul>
<p>Most filters implement the <code>OptionHandler</code> interface, which means you can set the options via a String array, rather than setting them each manually via <code>set</code>-methods.
For example, if you want to remove the <em>first</em> attribute of a dataset, you need this filter</p>
<pre><code class="java"> weka.filters.unsupervised.attribute.Remove
</code></pre>

<p>with this option</p>
<pre><code> -R 1
</code></pre>

<p>If you have an <code>Instances</code> object, called <code>data</code>, you can create and apply the filter like this:</p>
<pre><code class="java"> import weka.core.Instances;
 import weka.filters.Filter;
 import weka.filters.unsupervised.attribute.Remove;
 ...
 String[] options = new String[2];
 options[0] = &quot;-R&quot;;                                    // &quot;range&quot;
 options[1] = &quot;1&quot;;                                     // first attribute
 Remove remove = new Remove();                         // new instance of filter
 remove.setOptions(options);                           // set options
 remove.setInputFormat(data);                          // inform filter about dataset **AFTER** setting options
 Instances newData = Filter.useFilter(data, remove);   // apply filter
</code></pre>

<h2 id="filtering-on-the-fly">Filtering on-the-fly</h2>
<p>The <a href="http://weka.sourceforge.net/doc.dev/weka/classifiers/meta/FilteredClassifier.html">FilteredClassifer</a> meta-classifier is an easy way of filtering data on the fly. It removes the necessity of filtering the data before the classifier can be trained. Also, the data need not be passed through the trained filter again at prediction time. The following is an example of using this meta-classifier with the <code>Remove</code> filter and <code>J48</code> for getting rid of a numeric ID attribute in the data:</p>
<pre><code class="java"> import weka.classifiers.meta.FilteredClassifier;
 import weka.classifiers.trees.J48;
 import weka.filters.unsupervised.attribute.Remove;
 ...
 Instances train = ...         // from somewhere
 Instances test = ...          // from somewhere
 // filter
 Remove rm = new Remove();
 rm.setAttributeIndices(&quot;1&quot;);  // remove 1st attribute
 // classifier
 J48 j48 = new J48();
 j48.setUnpruned(true);        // using an unpruned J48
 // meta-classifier
 FilteredClassifier fc = new FilteredClassifier();
 fc.setFilter(rm);
 fc.setClassifier(j48);
 // train and make predictions
 fc.buildClassifier(train);
 for (int i = 0; i &lt; test.numInstances(); i++) {
   double pred = fc.classifyInstance(test.instance(i));
   System.out.print(&quot;ID: &quot; + test.instance(i).value(0));
   System.out.print(&quot;, actual: &quot; + test.classAttribute().value((int) test.instance(i).classValue()));
   System.out.println(&quot;, predicted: &quot; + test.classAttribute().value((int) pred));
 }
</code></pre>

<p>Other handy meta-schemes in Weka:</p>
<ul>
<li><a href="http://weka.sourceforge.net/doc.dev/weka/clusterers/FilteredClusterer.html">weka.clusterers.FilteredClusterer</a></li>
<li><a href="http://weka.sourceforge.net/doc.dev/weka/associations/FilteredAssociator.html">weka.assocations.FilteredAssociator</a></li>
</ul>
<h2 id="batch-filtering">Batch filtering</h2>
<p>On the command line, you can enable a second input/output pair (via <code>-r</code> and <code>-s</code>) with the <code>-b</code> option, in order to process the second file with the same filter setup as the first one. Necessary, if you're using attribute selection or standardization - otherwise you end up with incompatible datasets. This is done fairly easy, since one initializes the filter only once with the <code>setInputFormat(Instances)</code> method, namely with the training set, and then applies the filter subsequently to the training set <em>and</em> the test set. The following example shows how to apply the <code>Standardize</code> filter to a train and a test set.</p>
<pre><code class="java"> Instances train = ...   // from somewhere
 Instances test = ...    // from somewhere
 Standardize filter = new Standardize();
 filter.setInputFormat(train);  // initializing the filter once with training set
 Instances newTrain = Filter.useFilter(train, filter);  // configures the Filter based on train instances and returns filtered instances
 Instances newTest = Filter.useFilter(test, filter);    // create new test set
</code></pre>

<h2 id="calling-conventions">Calling conventions</h2>
<p>The <code>setInputFormat(Instances)</code> method <strong>always</strong> has to be the last call before the filter is applied, e.g., with <code>Filter.useFilter(Instances,Filter)</code>. <em>Why?</em> First, it is the convention for using filters and, secondly, lots of filters generate the header of the output format in the <code>setInputFormat(Instances)</code> method with the currently set options (setting otpions <em>after</em> this call doesn't have any effect any more).</p>
<h1 id="classification">Classification</h1>
<p>The necessary classes can be found in this package:</p>
<pre><code> weka.classifiers
</code></pre>

<h2 id="building-a-classifier">Building a Classifier</h2>
<h3 id="batch">Batch</h3>
<p>A Weka classifier is rather simple to train on a given dataset. E.g., we can train an unpruned C4.5 tree algorithm on a given dataset <em>data</em>. The training is done via the <code>buildClassifier(Instances)</code> method.</p>
<pre><code class="java"> import weka.classifiers.trees.J48;
 ...
 String[] options = new String[1];
 options[0] = &quot;-U&quot;;            // unpruned tree
 J48 tree = new J48();         // new instance of tree
 tree.setOptions(options);     // set the options
 tree.buildClassifier(data);   // build classifier
</code></pre>

<h3 id="incremental">Incremental</h3>
<p>Classifiers implementing the <code>weka.classifiers.UpdateableClassifier</code> interface can be trained incrementally. This conserves memory, since the data doesn't have to be loaded into memory all at once. See the Javadoc of this interface to see what classifiers are implementing it.</p>
<p>The actual process of training an incremental classifier is fairly simple:</p>
<ul>
<li>Call <code>buildClassifier(Instances)</code> with the structure of the dataset (may or may not contain any actual data rows).</li>
<li>Subsequently call the <code>updateClassifier(Instance)</code> method to feed the classifier new <code>weka.core.Instance</code> objects, one by one.</li>
</ul>
<p>Here is an example using data from a <code>weka.core.converters.ArffLoader</code> to train <code>weka.classifiers.bayes.NaiveBayesUpdateable</code>:</p>
<pre><code class="java"> // load data
 ArffLoader loader = new ArffLoader();
 loader.setFile(new File(&quot;/some/where/data.arff&quot;));
 Instances structure = loader.getStructure();
 structure.setClassIndex(structure.numAttributes() - 1);

 // train NaiveBayes
 NaiveBayesUpdateable nb = new NaiveBayesUpdateable();
 nb.buildClassifier(structure);
 Instance current;
 while ((current = loader.getNextInstance(structure)) != null)
   nb.updateClassifier(current);
</code></pre>

<p>A working example is <a href="../files/IncrementalClassifier.java">IncrementalClassifier.java</a>.</p>
<h2 id="evaluating">Evaluating</h2>
<h3 id="cross-validation">Cross-validation</h3>
<p>If you only have a training set and no test you might want to evaluate the classifier by using 10 times 10-fold cross-validation. This can be easily done via the <code>Evaluation</code> class. Here we <em>seed</em> the random selection of our folds for the CV with <em>1</em>. Check out the <code>Evaluation</code> class for more information about the statistics it produces.</p>
<pre><code class="java"> import weka.classifiers.Evaluation;
 import java.util.Random;
 ...
 Evaluation eval = new Evaluation(newData);
 eval.crossValidateModel(tree, newData, 10, new Random(1));
</code></pre>

<p><strong>Note:</strong> The classifier (in our example <em>tree</em>) should not be trained when handed over to the <code>crossValidateModel</code> method. <strong>Why?</strong> If the classifier does not abide to the Weka convention that a classifier must be re-initialized every time the <code>buildClassifier</code> method is called (in other words: subsequent calls to the <code>buildClassifier</code> method always return the same results), you will get inconsistent and worthless results. The <code>crossValidateModel</code> takes care of training and evaluating the classifier. (It creates a copy of the original classifier that you hand over to the <code>crossValidateModel</code> for each run of the cross-validation.)</p>
<h3 id="traintest-set">Train/test set</h3>
<p>In case you have a dedicated test set, you can train the classifier and then evaluate it on this test set. In the following example, a J48 is instantiated, trained and then evaluated. Some statistics are printed to <code>stdout</code>:</p>
<pre><code class="java"> import weka.core.Instances;
 import weka.classifiers.Evaluation;
 import weka.classifiers.trees.J48;
 ...
 Instances train = ...   // from somewhere
 Instances test = ...    // from somewhere
 // train classifier
 Classifier cls = new J48();
 cls.buildClassifier(train);
 // evaluate classifier and print some statistics
 Evaluation eval = new Evaluation(train);
 eval.evaluateModel(cls, test);
 System.out.println(eval.toSummaryString(&quot;\nResults\n======\n&quot;, false));
</code></pre>

<h3 id="statistics">Statistics</h3>
<p>Some methods for retrieving the results from the evaluation:</p>
<ul>
<li>
<p>nominal class</p>
<ul>
<li><code>correct()</code> - number of correctly classified instances (see also <code>incorrect()</code>)</li>
<li><code>pctCorrect()</code> - percentage of correctly classified instances (see also <code>pctIncorrect()</code>)</li>
<li><code>kappa()</code> - Kappa statistics</li>
</ul>
</li>
<li>
<p>numeric class</p>
<ul>
<li><code>correlationCoefficient()</code> - correlation coefficient</li>
</ul>
</li>
<li>
<p>general</p>
<ul>
<li><code>meanAbsoluteError()</code> - the mean absolute error</li>
<li><code>rootMeanSquaredError()</code> - the root mean squared error</li>
<li><code>unclassified()</code> - number of unclassified instances</li>
<li><code>pctUnclassified()</code> - percentage of unclassified instances</li>
</ul>
</li>
</ul>
<p>If you want to have the exact same behavior as from the command line, use this call:</p>
<pre><code class="java"> import weka.classifiers.trees.J48;
 import weka.classifiers.Evaluation;
 ...
 String[] options = new String[2];
 options[0] = &quot;-t&quot;;
 options[1] = &quot;/some/where/somefile.arff&quot;;
 System.out.println(Evaluation.evaluateModel(new J48(), options));
</code></pre>

<h3 id="roc-curvesauc">ROC curves/AUC</h3>
<p>You can also generate ROC curves/AUC with the predictions Weka recorded during testing. You can access these predictions via the <code>predictions()</code> method of the <code>Evaluation</code> class. See the [[Generating ROC curve]] article for a full example of how to generate ROC curves.</p>
<h2 id="classifying-instances">Classifying instances</h2>
<p>In case you have an unlabeled dataset that you want to classify with your newly trained classifier, you can use the following code snippet. It loads the file <code>/some/where/unlabeled.arff</code>, uses the previously built classifier <code>tree</code> to label the instances, and saves the labeled data as <code>/some/where/labeled.arff</code>.</p>
<pre><code class="java"> import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.FileReader;
 import java.io.FileWriter;
 import weka.core.Instances;
 ...
 // load unlabeled data
 Instances unlabeled = new Instances(
                         new BufferedReader(
                           new FileReader(&quot;/some/where/unlabeled.arff&quot;)));

 // set class attribute
 unlabeled.setClassIndex(unlabeled.numAttributes() - 1);

 // create copy
 Instances labeled = new Instances(unlabeled);

 // label instances
 for (int i = 0; i &lt; unlabeled.numInstances(); i++) {
   double clsLabel = tree.classifyInstance(unlabeled.instance(i));
   labeled.instance(i).setClassValue(clsLabel);
 }
 // save labeled data
 BufferedWriter writer = new BufferedWriter(
                           new FileWriter(&quot;/some/where/labeled.arff&quot;));
 writer.write(labeled.toString());
 writer.newLine();
 writer.flush();
 writer.close();
</code></pre>

<p><strong>Note on nominal classes:</strong></p>
<ul>
<li>If you're interested in the distribution over all the classes, use the method <code>distributionForInstance(Instance)</code>. This method returns a double array with the probability for each class.</li>
<li>The returned double value from <code>classifyInstance</code> (or the index in the array returned by <code>distributionForInstance</code>) is just the index for the string values in the attribute. That is, if you want the string representation for the class label returned above <code>clsLabel</code>, then you can print it like this:</li>
</ul>
<pre><code class="java">System.out.println(clsLabel + &quot; -&gt; &quot; + unlabeled.classAttribute().value((int) clsLabel));
</code></pre>

<h1 id="clustering">Clustering</h1>
<p>Clustering is similar to classification. The necessary classes can be found in this package:</p>
<pre><code> weka.clusterers
</code></pre>

<h2 id="building-a-clusterer">Building a Clusterer</h2>
<h3 id="batch_1">Batch</h3>
<p>A clusterer is built in much the same way as a classifier, but the <code>buildClusterer(Instances)</code> method instead of <code>buildClassifier(Instances)</code>. The following code snippet shows how to build an <code>EM</code> clusterer with a maximum of <code>100</code> iterations.</p>
<pre><code class="java"> import weka.clusterers.EM;
 ...
 String[] options = new String[2];
 options[0] = &quot;-I&quot;;                 // max. iterations
 options[1] = &quot;100&quot;;
 EM clusterer = new EM();   // new instance of clusterer
 clusterer.setOptions(options);     // set the options
 clusterer.buildClusterer(data);    // build the clusterer
</code></pre>

<h3 id="incremental_1">Incremental</h3>
<p>Clusterers implementing the <code>weka.clusterers.UpdateableClusterer</code> interface can be trained incrementally. This conserves memory, since the data doesn't have to be loaded into memory all at once. See the Javadoc for this interface to see which clusterers implement it.</p>
<p>The actual process of training an incremental clusterer is fairly simple:</p>
<ul>
<li>Call <code>buildClusterer(Instances)</code> with the structure of the dataset (may or may not contain any actual data rows).</li>
<li>Subsequently call the <code>updateClusterer(Instance)</code> method to feed the clusterer new <code>weka.core.Instance</code> objects, one by one.</li>
<li>Call <code>updateFinished()</code> after all Instance objects have been processed, for the clusterer to perform additional computations.</li>
</ul>
<p>Here is an example using data from a <code>weka.core.converters.ArffLoader</code> to train <code>weka.clusterers.Cobweb</code>:</p>
<pre><code class="java"> // load data
 ArffLoader loader = new ArffLoader();
 loader.setFile(new File(&quot;/some/where/data.arff&quot;));
 Instances structure = loader.getStructure();

 // train Cobweb
 Cobweb cw = new Cobweb();
 cw.buildClusterer(structure);
 Instance current;
 while ((current = loader.getNextInstance(structure)) != null)
   cw.updateClusterer(current);
 cw.updateFinished();
</code></pre>

<p>A working example is <a href="../files/IncrementalClusterer.java">IncrementalClusterer.java</a>.</p>
<h2 id="evaluating_1">Evaluating</h2>
<p>For evaluating a clusterer, you can use the <code>ClusterEvaluation</code> class. In this example, the number of clusters found is written to output:</p>
<pre><code class="java"> import weka.clusterers.ClusterEvaluation;
 import weka.clusterers.Clusterer;
 ...
 ClusterEvaluation eval = new ClusterEvaluation();
 Clusterer clusterer = new EM();                                 // new clusterer instance, default options
 clusterer.buildClusterer(data);                                 // build clusterer
 eval.setClusterer(clusterer);                                   // the cluster to evaluate
 eval.evaluateClusterer(newData);                                // data to evaluate the clusterer on
 System.out.println(&quot;# of clusters: &quot; + eval.getNumClusters());  // output # of clusters
</code></pre>

<p>Or, in the case of <a href="http://weka.sourceforge.net/doc/weka/clusterers/DensityBasedClusterer.html">DensityBasedClusterer</a>, you can cross-validate the clusterer (Note: with <a href="http://weka.sourceforge.net/doc/weka/clusterers/MakeDensityBasedClusterer.html">MakeDensityBasedClusterer</a> you can turn any clusterer into a density-based one):</p>
<pre><code class="java"> import weka.clusterers.ClusterEvaluation;
 import weka.clusterers.DensityBasedClusterer;
 import weka.core.Instances;
 import java.util.Random;
 ...
 Instances data = ...                                     // from somewhere
 DensityBasedClusterer clusterer = new ...                // the clusterer to evaluate
 double logLikelyhood =
    ClusterEvaluation.crossValidateModel(                 // cross-validate
    clusterer, data, 10,                                  // with 10 folds
    new Random(1));                                       // and random number generator with seed 1
</code></pre>

<p>Or, if you want the same behavior/print-out from command line, use this call:</p>
<pre><code class="java"> import weka.clusterers.EM;
 import weka.clusterers.ClusterEvaluation;
 ...
 String[] options = new String[2];
 options[0] = &quot;-t&quot;;
 options[1] = &quot;/some/where/somefile.arff&quot;;
 System.out.println(ClusterEvaluation.evaluateClusterer(new EM(), options));
</code></pre>

<h2 id="clustering-instances">Clustering instances</h2>
<p>The only difference with regard to classification is the method name. Instead of <code>classifyInstance(Instance)</code>, it is now <code>clusterInstance(Instance)</code>. The method for obtaining the distribution is still the same, i.e., <code>distributionForInstance(Instance)</code>.</p>
<h2 id="classes-to-clusters-evaluation">Classes to clusters evaluation</h2>
<p>If your data contains a class attribute and you want to check how well the generated clusters fit the classes, you can perform a so-called <em>classes to clusters</em> evaluation. The Weka Explorer offers this functionality, and it's quite easy to implement. These are the necessary steps (complete source code: <a href="../files/ClassesToClusters.java">ClassesToClusters.java</a>):</p>
<ul>
<li>load the data and set the class attribute</li>
</ul>
<pre><code class="java"> Instances data = new Instances(new BufferedReader(new FileReader(&quot;/some/where/file.arff&quot;)));
 data.setClassIndex(data.numAttributes() - 1);
</code></pre>

<ul>
<li>generate the <em>class-less</em> data to train the clusterer with</li>
</ul>
<pre><code class="java"> weka.filters.unsupervised.attribute.Remove filter = new weka.filters.unsupervised.attribute.Remove();
 filter.setAttributeIndices(&quot;&quot; + (data.classIndex() + 1));
 filter.setInputFormat(data);
 Instances dataClusterer = Filter.useFilter(data, filter);
</code></pre>

<ul>
<li>train the clusterer, e.g., <code>EM</code></li>
</ul>
<pre><code class="java"> EM clusterer = new EM();
 // set further options for EM, if necessary...
 clusterer.buildClusterer(dataClusterer);
</code></pre>

<ul>
<li>evaluate the clusterer with the data still containing the class attribute</li>
</ul>
<pre><code class="java"> ClusterEvaluation eval = new ClusterEvaluation();
 eval.setClusterer(clusterer);
 eval.evaluateClusterer(data);
</code></pre>

<ul>
<li>print the results of the evaluation to <em>stdout</em></li>
</ul>
<pre><code class="java"> System.out.println(eval.clusterResultsToString());
</code></pre>

<h1 id="attribute-selection">Attribute selection</h1>
<p>There is no real need to use the attribute selection classes directly in your own code, since there are already a meta-classifier and a filter available for applying attribute selection, but the low-level approach is still listed for the sake of completeness. The following examples all use <code>CfsSubsetEval</code> and <code>GreedyStepwise</code> (backwards). The code listed below is taken from the <a href="../files/AttributeSelectionTest.java">AttributeSelectionTest.java</a>.</p>
<h2 id="meta-classifier">Meta-Classifier</h2>
<p>The following meta-classifier performs a preprocessing step of attribute selection before the data gets presented to the base classifier (in the example here, this is <code>J48</code>).</p>
<pre><code class="java">  Instances data = ...  // from somewhere
  AttributeSelectedClassifier classifier = new AttributeSelectedClassifier();
  CfsSubsetEval eval = new CfsSubsetEval();
  GreedyStepwise search = new GreedyStepwise();
  search.setSearchBackwards(true);
  J48 base = new J48();
  classifier.setClassifier(base);
  classifier.setEvaluator(eval);
  classifier.setSearch(search);
  // 10-fold cross-validation
  Evaluation evaluation = new Evaluation(data);
  evaluation.crossValidateModel(classifier, data, 10, new Random(1));
  System.out.println(evaluation.toSummaryString());
</code></pre>

<h2 id="filter_1">Filter</h2>
<p>The filter approach is straightforward: after setting up the filter, one just filters the data through the filter and obtains the reduced dataset.</p>
<pre><code class="java">  Instances data = ...  // from somewhere
  AttributeSelection filter = new AttributeSelection();  // package weka.filters.supervised.attribute!
  CfsSubsetEval eval = new CfsSubsetEval();
  GreedyStepwise search = new GreedyStepwise();
  search.setSearchBackwards(true);
  filter.setEvaluator(eval);
  filter.setSearch(search);
  filter.setInputFormat(data);
  // generate new data
  Instances newData = Filter.useFilter(data, filter);
  System.out.println(newData);
</code></pre>

<h2 id="low-level">Low-level</h2>
<p>If neither the meta-classifier nor filter approach is suitable for your purposes, you can use the attribute selection classes themselves.</p>
<pre><code class="java">  Instances data = ...  // from somewhere
  AttributeSelection attsel = new AttributeSelection();  // package weka.attributeSelection!
  CfsSubsetEval eval = new CfsSubsetEval();
  GreedyStepwise search = new GreedyStepwise();
  search.setSearchBackwards(true);
  attsel.setEvaluator(eval);
  attsel.setSearch(search);
  attsel.SelectAttributes(data);
  // obtain the attribute indices that were selected
  int[] indices = attsel.selectedAttributes();
  System.out.println(Utils.arrayToString(indices));
</code></pre>

<h1 id="note-on-randomization">Note on randomization</h1>
<p>Most machine learning schemes, like classifiers and clusterers, are susceptible to the ordering of the data. Using a different seed for randomizing the data will most likely produce a different result. For example, the Explorer, or a classifier/clusterer run from the command line, uses only a seeded <code>java.util.Random</code> number generator, whereas the <code>weka.core.Instances.getRandomNumberGenerator(int)</code> (which the <a href="../files/WekaDemo.java">WekaDemo.java</a> uses) also takes the data into account for seeding. Unless one runs 10-fold cross-validation 10 times and averages the results, one will most likely get different results.</p>
<h1 id="see-also">See also</h1>
<ul>
<li><a href="../weka_examples/">Weka Examples</a> - pointer to collection of example classes</li>
<li><a href="../databases/">Databases</a> - for more information about using databases in Weka (includes ODBC, e.g., for MS Access)</li>
<li>[[weka_experiment_DatabaseUtils.props|weka/experiment/DatabaseUtils.props]] - the database setup file</li>
<li><a href="../generating_cv_folds_java/">Generating cross-validation folds (Java approach)</a> - in case you want to run 10-fold cross-validation manually</li>
<li>[[Generating classifier evaluation output manually]] - if you want to generate some of the evaluation statistics output manually</li>
<li><a href="../creating_arff_file/">Creating Instances on-the-fly</a> - explains how to generate a <code>weka.core.Instances</code> object from scratch</li>
<li>[[Save Instances to an ARFF File]] - shows how to output a dataset</li>
<li>[[Using the Experiment API]]</li>
</ul>
<h1 id="examples">Examples</h1>
<p>The following are a few sample classes for using various parts of the Weka API:</p>
<ul>
<li>
<p><a href="../files/WekaDemo.java">WekaDemo.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/classifiers/WekaDemo.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/classifiers/WekaDemo.java">developer</a>) - little demo class that loads data from a file, runs it through a filter and trains/evaluates a classifier</p>
</li>
<li>
<p><a href="../files/ClusteringDemo.java">ClusteringDemo.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/clusterers/ClusteringDemo.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/clusterers/ClusteringDemo.java">developer</a>) - a basic example for using the clusterer API</p>
</li>
<li>
<p><a href="../files/ClassesToClusters.java">ClassesToClusters.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/clusterers/ClassesToClusters.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/clusterers/ClassesToClusters.java">developer</a>) - performs a <em>classes to clusters</em> evaluation like in the Explorer</p>
</li>
<li>
<p><a href="../files/AttributeSelectionTest.java">AttributeSelectionTest.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/attributeSelection/AttributeSelectionTest.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/attributeSelection/AttributeSelectionTest.java">developer</a>) - example code for using the attribute selection API</p>
</li>
<li>
<p><a href="../files/M5PExample.java">M5PExample.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/classifiers/M5PExample.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/classifiers/M5PExample.java">developer</a>) - example using M5P to obtain data from database, train model, serialize it to a file, and use this serialized model to make predictions again.</p>
</li>
<li>
<p><a href="../files/OptionsToCode.java">OptionsToCode.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/core/OptionsToCode.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/core/OptionsToCode.java">developer</a>) - turns a Weka command line for a scheme with options into Java code, correctly escaping quotes and backslashes.</p>
</li>
<li>
<p><a href="../files/OptionTree.java">OptionTree.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/gui/OptionTree.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/gui/OptionTree.java">developer</a>) - displays nested Weka options as tree.</p>
</li>
<li>
<p><a href="../files/IncrementalClassifier.java">IncrementalClassifier.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/classifiers/IncrementalClassifier.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/classifiers/IncrementalClassifier.java">developer</a>) - Example class for how to train an incremental classifier (in this case, <code>weka.classifiers.bayes.NaiveBayesUpdateable</code>).</p>
</li>
<li>
<p><a href="../files/IncrementalClusterer.java">IncrementalClusterer.java</a> (<a href="https://svn.cms.waikato.ac.nz/svn/weka/branches/stable-3-8/wekaexamples/src/main/java/wekaexamples/clusterers/IncrementalClusterer.java">stable</a>, <a href="https://svn.cms.waikato.ac.nz/svn/weka/trunk/wekaexamples/src/main/java/wekaexamples/clusterers/IncrementalClusterer.java">developer</a>) - Example class for how to train an incremental clusterer (in this case, <code>weka.clusterers.Cobweb</code>).</p>
</li>
</ul>
<h1 id="links">Links</h1>
<ul>
<li>Weka API<ul>
<li><a href="http://weka.sourceforge.net/doc.stable/">Stable version</a></li>
<li><a href="../[http://weka.sourceforge.net/doc.dev/">Developer version</a></li>
</ul>
</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../weka_examples/" class="btn btn-neutral float-right" title=" Weka Examples">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../databases/" class="btn btn-neutral" title=" Databases"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../databases/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../weka_examples/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js"></script>
      <script src="../search/require.js"></script>
      <script src="../search/search.js"></script>

</body>
</html>
