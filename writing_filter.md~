**Note:** This is also covered in chapter *Extending WEKA* of the WEKA manual.

# Packages
A few comments about the different filter sub-packages:

* `supervised` - contains supervised filters, i.e., filters that take class distributions into account. Must implement the `weka.filters.SupervisedFilter` interface.

    * `attribute` - filters that work column-wise.
    * `instance` - filters that work row-wise.

* `unsupervised` - contains unsupervised filters, i.e., they work without taking any class distributions into account. Must implement the `weka.filters.UnsupervisedFilter` interface.

    * `attribute` - filters that work column-wise.
    * `instance` - filters that work row-wise.

# Choosing the superclass
The base filters and interfaces are all located in the following package:

```
 weka.filters
```

One can basically distinguish between two different kinds of filters:

* **batch filters** - they need to see the whole dataset before they can start processing it, which they do in one go
* **stream filters** - they can start producing output right away and the data just passes through while being modified

All filters are derived from the abstract superclass `weka.filters.Filter`.

To speed up development, there are also the following abstract filters, depending on the kind of classifier you want to implement:

* `weka.filters.SimpleBatchFilter`
* `weka.filters.SimpleStreamFilter`

These filters simplify the rather general and complex framework introduced by the abstract superclass `weka.filters.Filter`. One only needs to implement a couple of abstract methods that will process the actual data and override, if necessary, a few existing methods for option handling.

## Filter


## SimpleBatchFilter
Only the following abstract methods need to be implemented:

* `globalInfo()` - returns a short description of what the filter does; will be displayed in the GUI
* `determineOutputFormat(Instances)` - generates the new format, based on the input data
* `process(Instances)` - processes the whole dataset in one go
* `getRevision()` - returns the [Subversion](subversion.md) revision information

If you need access to the full input dataset in `determineOutputFormat(Instances)`, then you need to also override the method `allowAccessToFullInputFormat()` and make it return true. 

If more options are necessary, then the following methods need to be overridden:

* `listOptions()` - returns an enumeration of the available options; these are printed if one calls the filter with the *-h* option
* `setOptions(String[])` - parses the given option array, that were passed from commandline
* `getOptions()` - returns an array of options, resembling the current setup of the filter

In the following an **example implementation** that adds an additional attribute at the end, containing the index of the processed instance:

```java
 import weka.core.*;
 import weka.core.Capabilities.*;
 import weka.filters.*;

 public class SimpleBatch
   extends SimpleBatchFilter {

   public String globalInfo() {
     return   "A simple batch filter that adds an additional attribute 'bla' at the end "
            + "containing the index of the processed instance.";
   }

   public Capabilities getCapabilities() {
     Capabilities result = super.getCapabilities();
     result.enableAllAttributes();
     result.enableAllClasses();
     result.enable(Capability.NO_CLASS);  //// filter doesn't need class to be set//
     return result;
   }

   protected Instances determineOutputFormat(Instances inputFormat) {
     Instances result = new Instances(inputFormat, 0);
     result.insertAttributeAt(new Attribute("bla"), result.numAttributes());
     return result;
   }

   protected Instances process(Instances inst) {
     Instances result = new Instances(determineOutputFormat(inst), 0);
     for (int i = 0; i < inst.numInstances(); i++) {
       double[] values = new double[result.numAttributes()];
       for (int n = 0; n < inst.numAttributes(); n++)
         values[n] = inst.instance(i).value(n);
       values[values.length - 1] = i;
       result.add(new Instance(1, values));
     }
     return result;
   }

   public static void main(String[] args) {
     runFilter(new SimpleBatch(), args);
   }
 }
```

## SimpleStreamFilter
Only the following abstract methods need to be implemented:

* `globalInfo()` - returns a short description of what the filter does; will be displayed in the GUI
* `determineOutputFormat(Instances)` - generates the new format, based on the input data
* `process(Instance)`processes a single instance and turns it from the old format into the new one
* `getRevision()` - returns the [Subversion](subversion.md) revision information

The `reset()` method is only used, since the random number generator needs to be re-initialized in order to obtain repeatable results.

If more options are necessary, then the following methods need to be overridden:

* `listOptions()` - returns an enumeration of the available options; these are printed if one calls the filter with the *-h* option
* `setOptions(String[])` - parses the given option array, that were passed from commandline
* `getOptions()` - returns an array of options, resembling the current setup of the filter

In the following an **example implementation** of a stream filter that adds an extra attribute at the end, which is filled with random numbers:

```java
 import weka.core.*;
 import weka.core.Capabilities.*;
 import weka.filters.*;

 import java.util.Random;

 public class SimpleStream
   extends SimpleStreamFilter {

   protected Random m_Random;

   public String globalInfo() {
     return   "A simple stream filter that adds an attribute 'bla' at the end "
            + "containing a random number.";
   }

   public Capabilities getCapabilities() {
     Capabilities result = super.getCapabilities();
     result.enableAllAttributes();
     result.enableAllClasses();
     result.enable(Capability.NO_CLASS);  //// filter doesn't need class to be set//
     return result;
   }

   protected void reset() {
     super.reset();
     m_Random = new Random(1);
   }

   protected Instances determineOutputFormat(Instances inputFormat) {
     Instances result = new Instances(inputFormat, 0);
     result.insertAttributeAt(new Attribute("bla"), result.numAttributes());
     return result;
   }

   protected Instance process(Instance inst) {
     double[] values = new double[inst.numAttributes() + 1];
     for (int n = 0; n < inst.numAttributes(); n++)
       values[n] = inst.value(n);
     values[values.length - 1] = m_Random.nextInt();
     Instance result = new Instance(1, values);
     return result;
   }

   public static void main(String[] args) {
     runFilter(new SimpleStream(), args);
   }
 }
```

A **real-world** implementation of a stream filter is the `MultiFilter` (package `weka.filters`), which passes the data through all the filters it contains. Depending on whether all the used filters are streamable or not, it acts either as a stream filter or as batch filter.

# Internals
Some useful methods of the filter classes:

* `isNewBatch()` - returns `true` if an instance of the filter was just instantiated via `new` or a new batch was started via the `batchFinished()` method.
* `isFirstBatchDone()` - returns `true` as soon as the first batch was finished via the `batchFinished()` method. Useful for *supervised* filters, which should not be altered after being trained with the first batch of instances.

# Revisions
Filters also implement the `weka.core.RevisionHandler` interface. This provides the functionality of obtaining the [Subversion](subversion.md) revision from within Java. Filters that are not part of the official Weka distribution will have to implement the method `getRevision()` as follows, which will return a dummy revision of *1.0*:

```java
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
    return RevisionUtils.extract("$Revision: 1.0 $");
  }
```

# Integration
After finishing the coding stage, it's time to integrate your filter in the Weka framework, i.e., to make it available in the Explorer, Experimenter, etc.

The [[GenericObjectEditor]] article shows you how to tell Weka where to find your filter and therefore displaying it in the *GenericObjectEditor* (filters work in the same fashion as classifiers, regarding the discovery).

# Testing
Weka provides already a test framework to ensure the basic functionality of a filter. It is essential for the filter to pass these tests.

## Option handling 
If your filter implements `weka.core.OptionHandler`, check the **option handling** of your filter with the following tool from commandline:

```
 weka.core.CheckOptionHandler -W classname [-- additional parameters]
```

All tests need to return *yes*.

## GenericObjectEditor
The `CheckGOE` class checks whether all the properties available in the GUI have a tooltip accompanying them and whether the `globalInfo()` method is declared:

```
 weka.core.CheckGOE -W classname [-- additional parameters]
```

All tests, once again, need to return *yes*.

## Source code
Filters that implement the `weka.filters.Sourcable` interface can output Java code of their internal representation. In order to check the generated code, one should not only compile the code, but also test it with the following test class:

```
 weka.filters.CheckSource
```

This class takes the original Weka filter, the generated code and the dataset used for generating the source code (and an optional class index) as parameters. It builds the Weka filter on the dataset and compares the output, the one from the Weka filter and the one from the generated source code, whether they are the same.

Here's an example call for `weka.filters.unsupervised.attribute.ReplaceMissingValues` and the generated class `weka.filters.WekaWrapper` (it wraps the actual generated code in a pseudo-filter):

```
 java weka.filters.CheckSource \
    -W weka.filters.unsupervised.attribute.ReplaceMissingValues \
    -S weka.filters.WekaWrapper \
    -t data.arff
```

It needs to return *Tests OK!*.

## Unit tests
In order to make sure that your filter applies to the Weka criteria, you should add your filter to the [junit](http://www.junit.org/) unit test framework, i.e., by creating a Test class.

How to check out the unit test framework, you can find [here](subversion.md#junit).


# See also
* [[GenericObjectEditor|GenericObjectEditor/GenericPropertiesCreator]]

# Links 
* [junit](http://www.junit.org/)

